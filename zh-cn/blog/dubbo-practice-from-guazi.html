<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="dubbo-practice-from-guazi" />
	<meta name="description" content="dubbo-practice-from-guazi" />
	<!-- 网页标签标题 -->
	<title>dubbo-practice-from-guazi</title>
	<link rel="shortcut icon" href="/img/dubbo.ico"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="/img/dubbo_colorful.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="/img/menu_gray.png"/><ul><li class="menu-item menu-item-normal"><a target="_self" href="/zh-cn/index.html">首页</a></li><li class="menu-item menu-item-normal"><a target="_self" href="/zh-cn/docs/user/quick-start.html">文档</a></li><li class="menu-item menu-item-normal"><a target="_self" href="/zh-cn/docs/developers/developers_dev.html">开发者</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a target="_self" href="/zh-cn/blog/index.html">博客</a></li><li class="menu-item menu-item-normal"><a target="_self" href="/zh-cn/community/index.html">社区</a></li><li class="menu-item menu-item-normal"><a target="_self" href="/zh-cn/ecology/index.html">生态系统</a></li><li class="menu-item menu-item-normal"><a target="_self" href="/zh-cn/blog/download.html">下载</a></li></ul></div></div></header><section class="blog-content markdown-body"><h1>dubbo在瓜子二手车的实践</h1>
<h2>前言</h2>
<p>  随着瓜子业务的不断发展，系统规模在逐渐扩大，目前在瓜子的私有云上已经运行着数百个dubbo应用，上千个dubbo实例。瓜子各部门业务迅速发展，版本没有来得及统一，各个部门都有自己的用法。随着第二机房的建设，dubbo版本统一的需求变得越发迫切。几个月前，公司发生了一次与dubbo相关的生产事故，成为了公司dubbo版本升级的诱因。</p>
<p>  接下来，我会从这次事故开始，讲讲我们这段时间所做的dubbo版本升级的历程以及dubbo后续多机房的方案。</p>
<h2>一、Ephermal节点未及时删除导致provider不能恢复注册的问题修复</h2>
<h3>事故背景</h3>
<p>  在生产环境，瓜子内部各业务线共用一套zookeeper集群作为dubbo的注册中心。2019年9月份，机房的一台交换机发生故障，导致zookeeper集群出现了几分钟的网络波动。在zookeeper集群恢复后，正常情况下dubbo的provider应该会很快重新注册到zookeeper上，但有一小部分的provider很长一段时间没有重新注册到zookeeper上，直到手动重启应用后才恢复注册。</p>
<h3>排查过程</h3>
<p>  首先，我们统计了出现这种现象的dubbo服务的版本分布情况，发现在大多数的dubbo版本中都存在这种问题，且发生问题的服务比例相对较低，在github中我们也未找到相关问题的issues。因此，推断这是一个尚未修复的且在网络波动情况的场景下偶现的问题。</p>
<p>  接着，我们便将出现问题的应用日志、zookeeper日志与dubbo代码逻辑进行相互印证。在应用日志中，应用重连zookeeper成功后provider立刻进行了重新注册，之后便没有任何日志打印。而在zookeeper日志中，注册节点被删除后，并没有重新创建注册节点。对应到dubbo的代码中，只有在<code>FailbackRegistry.register(url)</code>的<code>doRegister(url)</code>执行成功或线程被挂起的情况下，才能与日志中的情况相吻合。</p>
<pre><code class="language-java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(URL url)</span> </span>{
        <span class="hljs-keyword">super</span>.register(url);
        failedRegistered.remove(url);
        failedUnregistered.remove(url);
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// Sending a registration request to the server side</span>
            doRegister(url);
        } <span class="hljs-keyword">catch</span> (Exception e) {
            Throwable t = e;

            <span class="hljs-comment">// If the startup detection is opened, the Exception is thrown directly.</span>
            <span class="hljs-keyword">boolean</span> check = getUrl().getParameter(Constants.CHECK_KEY, <span class="hljs-keyword">true</span>)
                    &amp;&amp; url.getParameter(Constants.CHECK_KEY, <span class="hljs-keyword">true</span>)
                    &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());
            <span class="hljs-keyword">boolean</span> skipFailback = t <span class="hljs-keyword">instanceof</span> SkipFailbackWrapperException;
            <span class="hljs-keyword">if</span> (check || skipFailback) {
                <span class="hljs-keyword">if</span> (skipFailback) {
                    t = t.getCause();
                }
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Failed to register "</span> + url + <span class="hljs-string">" to registry "</span> + getUrl().getAddress() + <span class="hljs-string">", cause: "</span> + t.getMessage(), t);
            } <span class="hljs-keyword">else</span> {
                logger.error(<span class="hljs-string">"Failed to register "</span> + url + <span class="hljs-string">", waiting for retry, cause: "</span> + t.getMessage(), t);
            }

            <span class="hljs-comment">// Record a failed registration request to a failed list, retry regularly</span>
            failedRegistered.add(url);
        }
    }
</code></pre>
<p>  在继续排查问题前，我们先普及下这些概念：dubbo默认使用curator作为zookeeper的客户端，curator与zookeeper是通过session维持连接的。当curator重连zookeeper时，若session未过期，则继续使用原session进行连接；若session已过期，则创建新session重新连接。而ephemeral节点与session是绑定的关系，在session过期后，会删除此session下的ephemeral节点。</p>
<p>  继续对<code>doRegister(url)</code>的代码进行进一步排查，我们发现在<code>CuratorZookeeperClient.createEphemeral(path)</code>方法中有这么一段逻辑：在<code>createEphemeral(path)</code>捕获了<code>NodeExistsException</code>，创建ephemeral节点时，若此节点已存在，则认为ephemeral节点创建成功。这段逻辑初看起来并没有什么问题，且在以下两种常见的场景下表现正常：</p>
<ol>
<li>Session未过期，创建Ephemeral节点时原节点仍存在,不需要重新创建</li>
<li>Session已过期，创建Ephemeral节点时原节点已被zookeeper删除，创建成功</li>
</ol>
<pre><code class="language-java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createEphemeral</span><span class="hljs-params">(String path)</span> </span>{
        <span class="hljs-keyword">try</span> {
            client.create().withMode(CreateMode.EPHEMERAL).forPath(path);
        } <span class="hljs-keyword">catch</span> (NodeExistsException e) {
        } <span class="hljs-keyword">catch</span> (Exception e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(e.getMessage(), e);
        }
    }
</code></pre>
<p>  但是实际上还有一种极端场景，<strong>zookeeper的Session过期与删除Ephemeral节点不是原子性的</strong>，也就是说客户端在得到Session过期的消息时，Session对应的Ephemeral节点可能还未被zookeeper删除。此时dubbo去创建Ephemeral节点,发现原节点仍存在，故不重新创建。待Ephemeral节点被zookeeper删除后，便会出现dubbo认为重新注册成功，但实际未成功的情况，也就是我们在生产环境遇到的问题。</p>
<p>  此时，问题的根源已被定位。定位问题之后，我们与dubbo社区交流，发现考拉的同学也遇到过同样的问题，更确定了这个原因。</p>
<h3>问题的复现与修复</h3>
<p>  定位到问题之后，我们便开始尝试本地复现。由于zookeeper的Session过期但Ephemeral节点未被删除的场景直接模拟比较困难，我们通过修改zookeeper源码，在Session过期与删除Ephemeral节点的逻辑中增加了一段休眠时间，间接模拟出这种极端场景，并在本地复现了此问题。</p>
<p>  在排查问题的过程中，我们发现kafka的旧版本在使用zookeeper时也遇到过类似的问题，并参考kafka关于此问题的修复方案，确定了dubbo的修复方案。在创建Ephemeral节点捕获到<code>NodeExistsException</code>时进行判断，若Ephemeral节点的SessionId与当前客户端的SessionId不同，则删除并重建Ephemeral节点。在内部修复并验证通过后，我们向社区提交了issues及pr。</p>
<p>  kafka类似问题issues：<a href="https://issues.apache.org/jira/browse/KAFKA-1387">https://issues.apache.org/jira/browse/KAFKA-1387</a></p>
<p>  dubbo注册恢复问题issues：<a href="https://github.com/apache/dubbo/issues/5125">https://github.com/apache/dubbo/issues/5125</a></p>
<h2>二、瓜子的dubbo升级历程</h2>
<p>  上文中的问题修复方案已经确定，但我们显然不可能在每一个dubbo版本上都进行修复。在咨询了社区dubbo的推荐版本后，我们决定在dubbo2.7.3版本的基础上，开发内部版本修复来这个问题。并借这个机会，开始推动公司dubbo版本的统一升级工作。</p>
<h3>为什么要统一dubbo版本</h3>
<ol>
<li>统一dubbo版本后，我们可以在此版本上内部紧急修复一些dubbo问题（如上文的dubbo注册故障恢复失效问题）。</li>
<li>瓜子目前正在进行第二机房的建设，部分dubbo服务也在逐渐往第二机房迁移。统一dubbo版本，也是为dubbo的多机房做铺垫。</li>
<li>有利于我们后续对dubbo服务的统一管控。</li>
<li>dubbo社区目前的发展方向与我们公司现阶段对dubbo的一些诉求相吻合，如支持gRPC、云原生等。</li>
</ol>
<h3>为什么选择dubbo2.7.3</h3>
<ol>
<li>在我们之前，携程与dubbo社区合作进行了携程dubbo内部版本的升级，并在社区2.7.3版本上修复了很多兼容性问题。感谢携程的同学帮我们踩坑～</li>
<li>dubbo2.7.3版本在当时虽然是最新的版本，但已经发布了2个月的时间，从社区issues反馈来看，dubbo2.7.3相对dubbo2.7之前的几个版本，在兼容性方面要好很多。</li>
<li>我们也咨询了dubbo社区的同学，推荐升级版本为2.7.3。</li>
</ol>
<h3>内部版本定位</h3>
<p>  基于社区dubbo2.7.3版本开发的dubbo内部版本属于过渡性质的版本，目的是为了修复线上provider不能恢复注册的问题，以及一些社区dubbo2.7.3的兼容性问题。瓜子的dubbo最终还是要跟随社区的版本，而不是开发自已的内部功能。因此我们在dubbo内部版本中修复的所有问题均与社区保持了同步，以保证后续可以兼容升级到社区dubbo的更高版本。</p>
<h3>兼容性验证与升级过程</h3>
<p>  我们在向dubbo社区的同学咨询了版本升级方面的相关经验后，于9月下旬开始了dubbo版本的升级工作。</p>
<ol>
<li><strong>初步兼容性验证</strong>
首先,我们梳理了一些需要验证的兼容性case，针对公司内部使用较多的dubbo版本，与dubbo2.7.3一一进行了兼容性验证。经验证，除dubboX外，dubbo2.7.3与其他dubbo版本均兼容。dubboX由于对dubbo协议进行了更改，与dubbo2.7.3不兼容。</li>
<li><strong>生产环境兼容性验证</strong>
在初步验证兼容性通过后，我们与业务线合作，挑选了一些重要程度较低的项目，在生产环境对dubbo2.7.3与其他版本的兼容性进行了进一步验证。并在内部版本修复了一些兼容性问题。</li>
<li><strong>推动公司dubbo版本升级</strong>
在10月初，完成了dubbo兼容性验证后，我们开始在各个业务线推动dubbo的升级工作。截止到12月初,已经有30%的dubbo服务的完成了版本升级。按照排期，预计于2020年3月底前完成公司dubbo版本的统一升级。</li>
</ol>
<h3>兼容性问题汇总</h3>
<p>  在推动升级dubbo2.7.3版本的过程整体上比较顺利,当然也遇到了一些兼容性问题：</p>
<ul>
<li>
<p><strong>创建zookeeper节点时提示没有权限</strong>
dubbo配置文件中已经配置了zookeeper的用户名密码，但在创建zookeeper节点时却抛出<code>KeeperErrorCode = NoAuth</code>的异常，这种情况分别对应两个兼容性问题：</p>
<ul>
<li>issues:<a href="https://github.com/apache/dubbo/issues/5076">https://github.com/apache/dubbo/issues/5076</a>
dubbo在未配置配置中心时，默认使用注册中心作为配置中心。通过注册中心的配置信息初始化配置中心配置时，由于遗漏了用户名密码，导致此问题。</li>
<li>issues:<a href="https://github.com/apache/dubbo/issues/4991">https://github.com/apache/dubbo/issues/4991</a>
dubbo在建立与zookeeper的连接时会根据zookeeper的address复用之前已建立的连接。当多个注册中心使用同一个address，但权限不同时，就会出现<code>NoAuth</code>的问题。
参考社区的pr，我们在内部版本进行了修复。</li>
</ul>
</li>
<li>
<p><strong>curator版本兼容性问题</strong></p>
<ul>
<li>dubbo2.7.3与低版本的curator不兼容，因此我们默认将curator版本升级至4.2.0</li>
</ul>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
</code></pre>
<ul>
<li>分布式调度框架elastic-job-lite强依赖低版本的curator,与dubbo2.7.3使用的curator版本不兼容,这给dubbo版本升级工作带来了一定阻塞。考虑到elastic-job-lite已经很久没有人进行维护，目前一些业务线计划将elastic-job-lite替换为其他的调度框架。</li>
</ul>
</li>
<li>
<p><strong>openFeign与dubbo兼容性问题</strong>
issues: <a href="https://github.com/apache/dubbo/issues/3990">https://github.com/apache/dubbo/issues/3990</a>
dubbo的ServiceBean监听spring的ContextRefreshedEvent,进行服务暴露。openFeign提前触发了ContextRefreshedEvent，此时ServiceBean还未完成初始化，于是就导致了应用启动异常。
参考社区的pr，我们在内部版本修复了此问题。</p>
</li>
<li>
<p><strong>RpcException兼容性问题</strong>
dubbo低版本consumer不能识别dubbo2.7版本provider抛出的<code>org.apache.dubbo.rpc.RpcException</code>。因此，在consumer全部升级到2.7之前，不建议将provider的<code>com.alibaba.dubbo.rpc.RpcException</code>改为<code>org.apache.dubbo.rpc.RpcException</code></p>
</li>
<li>
<p><strong>qos端口占用</strong>
dubbo2.7.3默认开启qos功能，导致一些混部在物理机的dubbo服务升级时出现qos端口占用问题。关闭qos功能后恢复。</p>
</li>
<li>
<p><strong>自定义扩展兼容性问题</strong>
业务线对于dubbo的自定义扩展比较少，因此在自定义扩展的兼容性方面暂时还没有遇到比较难处理的问题，基本上都是变更package导致的问题，由业务线自行修复。</p>
</li>
<li>
<p><strong>skywalking agent兼容性问题</strong>
我们项目中一般使用skywalking进行链路追踪，由于skywalking agent6.0的plugin不支持dubbo2.7，因此统一升级skywalking agent到6.1。</p>
</li>
</ul>
<h2>三、dubbo多机房方案</h2>
<p>  瓜子目前正在进行第二机房的建设工作，dubbo多机房是第二机房建设中比较重要的一个话题。在dubbo版本统一的前提下，我们就能够更顺利的开展dubbo多机房相关的调研与开发工作。</p>
<h3>初步方案</h3>
<p>  我们咨询了dubbo社区的建议，并结合瓜子云平台的现状，初步确定了dubbo多机房的方案。</p>
<ol>
<li>在每个机房内，部署一套独立的zookeeper集群。集群间信息不同步。这样就没有了zookeeper集群跨机房延迟与数据不同步的问题。</li>
<li>dubbo服务注册时，仅注册到本机房的zookeeper集群；订阅时，同时订阅两个机房的zookeeper集群。</li>
<li>实现同机房优先调用的路由逻辑。以减少跨机房调用导致的不必要网络延迟。</li>
</ol>
<h3>同机房优先调用</h3>
<p>  dubbo同机房优先调用的实现比较简单，相关逻辑如下：</p>
<ol>
<li>瓜子云平台默认将机房的标志信息注入容器的环境变量中。</li>
<li>provider暴露服务时，读取环境变量中的机房标志信息，追加到待暴露服务的url中。</li>
<li>consumer调用provider时，读取环境变量中的机房标志信息，根据路由策略优先调用具有相同标志信息的provider。</li>
</ol>
<p>  针对以上逻辑，我们简单实现了dubbo通过环境变量进行路由的功能，并向社区提交了pr。
  dubbo通过环境变量路由pr: <a href="https://github.com/apache/dubbo/pull/5348">https://github.com/apache/dubbo/pull/5348</a></p>
</section><footer class="footer-container"><div class="footer-body"><img src="/img/dubbo_gray.png"/><img class="apache" src="/img/apache_logo.png"/><div class="cols-container"><div class="col col-12"><h3></h3><p></p></div><div class="col col-4"><dl><dt>ASF</dt><dd><a href="http://www.apache.org" target="_self">基金会</a></dd><dd><a href="http://www.apache.org/licenses/" target="_self">证书</a></dd><dd><a href="http://www.apache.org/events/current-event" target="_self">事件</a></dd><dd><a href="http://www.apache.org/foundation/sponsorship.html" target="_self">赞助</a></dd><dd><a href="http://www.apache.org/foundation/thanks.html" target="_self">致谢</a></dd></dl></div><div class="col col-4"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/user/quick-start.html" target="_self">快速开始</a></dd><dd><a href="/zh-cn/docs/dev/build.html" target="_self">开发者指南</a></dd><dd><a href="/zh-cn/docs/admin/ops/dubbo-ops.html" target="_self">运维管理</a></dd><dd><a href="https://github.com/apache/dubbo-website/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/apache/dubbo-website" target="_self">编辑此文档</a></dd></dl></div><div class="col col-4"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd><dd><a href="https://www.apache.org/security" target="_self">安全</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2018-2019 The Apache Software Foundation. Apache and the Apache feather logo are trademarks of The Apache Software Foundation.</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
  <script src="/build/blogDetail.js"></script>
  <!-- Global site tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-112489517-1"></script>
	<script>
		window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-112489517-1');
	</script>
</body>
</html>